# Benchmark Comparison: tweets(created_at DESC, id DESC) Index

## テスト環境
- データ量: Users 1,000人, Tweets 100,000件, Follows 10,000件
- 測定ツール: Apache Bench (ab)
- 設定: 100リクエスト, 同時接続数10

## 結果比較

### Test 1: GET /tweets (count=20, cursor=0)
最初のページを取得

| 状態 | Requests/sec | Mean Time | 改善率 |
|------|--------------|-----------|--------|
| インデックスなし | 6,116.96 | 1.635ms | - |
| インデックスあり | 11,277.77 | 0.887ms | **84.4%高速化** ✓ |

### Test 2: GET /tweets (count=20, cursor=1000)
深いページネーション（OFFSET 1000）

| 状態 | Requests/sec | Mean Time | 改善率 |
|------|--------------|-----------|--------|
| インデックスなし | 11,784.12 | 0.849ms | - |
| インデックスあり | 11,941.72 | 0.837ms | 1.3%高速化 |

### Test 3: GET /tweets (count=100, cursor=0)
大量取得

| 状態 | Requests/sec | Mean Time | 改善率 |
|------|--------------|-----------|--------|
| インデックスなし | 13,312.03 | 0.751ms | - |
| インデックスあり | 12,310.72 | 0.812ms | **7.5%低下** ✗ |

### Test 4: GET /users/me/feed (count=20, cursor=0)
フィード取得（最初のページ）

| 状態 | Requests/sec | Mean Time | 改善率 |
|------|--------------|-----------|--------|
| インデックスなし | 13,262.60 | 0.754ms | - |
| インデックスあり | 13,424.62 | 0.745ms | 1.2%高速化 |

### Test 5: GET /users/me/feed (count=20, cursor=100)
フィード取得（深いページ）

| 状態 | Requests/sec | Mean Time | 改善率 |
|------|--------------|-----------|--------|
| インデックスなし | 12,894.91 | 0.775ms | - |
| インデックスあり | 11,981.79 | 0.835ms | **7.1%低下** ✗ |

## 考察

### ポジティブな結果
- **Test 1 (最初のページ)**: 84.4%の大幅な高速化
  - インデックスが最も効果を発揮するケース
  - LIMIT 20のみで、OFFSETが小さい場合はインデックススキャンが効率的

### ネガティブな結果
- **Test 3 (大量取得)**: 7.5%の性能低下
- **Test 5 (深いページのフィード)**: 7.1%の性能低下

### 可能性のある原因
1. **データ量が少ない**
   - 10万件のデータでは、フルテーブルスキャン+ソートの方が効率的な場合がある
   - PostgreSQLのクエリプランナーがインデックスを選択しない可能性

2. **キャッシュの影響**
   - 最初のベンチマークでデータがキャッシュに乗った
   - 2回目のベンチマークでキャッシュヒット率が高く、差が縮まった

3. **OFFSET の問題**
   - OFFSET + LIMITはページが深くなるほど非効率
   - インデックスありでもOFFSET 1000は遅い

4. **クエリプランナーの判断**
   - 大量取得（LIMIT 100）では、インデックススキャンよりSeq Scanが選択されている可能性

## 次のステップ
1. **EXPLAIN ANALYZE で実行計画を確認**
   - インデックスが実際に使用されているか確認
   - Seq Scan vs Index Scan の判定

2. **データ量を増やして再測定**
   - 100万件、1000万件で再度ベンチマーク
   - データ量が多い場合のインデックス効果を確認

3. **キャッシュをクリアして再測定**
   - PostgreSQLのキャッシュをクリアして公平な測定

4. **代替インデックスの検討**
   - tweets(user_id) の単一インデックス
   - tweets(user_id, created_at DESC) の複合インデックス
